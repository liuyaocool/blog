# 常见排序算法对比

| 名称                  | 平均O()   | 最坏O()   | 最好O()   | 空间复杂度 | 稳定性 |
| --------------------- | --------- | --------- | --------- | ---------- | ------ |
| 选择排序（Selection） | n^2       | n^2       | n^2       | 1          | 不稳   |
| 冒泡排序（Bubble）    | n^2       | n^2       | n         | 1          | 稳     |
| 插入排序（Insertion） | n^2       | n^2       | n         | 1          | 稳     |
| 堆排序（heap）        | n*log_2`n | n*log_2`n | n*log_2`n | 1          | 不稳   |
| 希尔排序（Shell）     | n^1.3     | n^2       | n         | 1          | 不稳   |
| 归并排序（Merge）     | n*log_2`n | n*log_2`n | n*log_2`n | n          | 稳     |
| 快速排序（Quick）     | n*log_2`n | n^2       | n*log_2`n | n*log_2`n  | 不稳   |
| 桶排序（Bucket）      | n+k       | n^2       | n         | n+k        | 稳     |
| 计数排序（Counting）  | n+k       | n+k       | n+k       | n+k        | 稳     |
| 基数排序（Radix）     | n*k       | n*k       | n*k       | n+k        | 稳     |

# 选择排序：

1. 0~n-1 最小放到0
2. 1~n-1 最小放到1
3. 。。。

# 冒泡排序：

1. 0~1、1~2、2~3、。。n-2~n-1 大的后放
2. 0~1、1~2、2~3、。。n-3~n-2 大的后放
3. 。。。

# 插入排序：

有点像摸牌，前边已经排好了，新牌从后往前排插入

1. 0~1 ：1位置与前边比较，前一个比自己大 往前换，直到前边<=自己 停止
2. 0~2 ：2位置与前边比较，。。。
3. 0~3 ：3位置与前边比较，。。。
4. ...

# 希尔排序： 间隔插入排序

-  间隔序列Knuth： h=1 h=3*h+1=4 h=3*4+1=13 ...
- 例如：间隔取4， 则取 i%4 == 0 的为一组排序（仍在原数组，只不过下标间隔为4），排完之后在以间隔为2的排序，最终以间隔为1排序
  - 即 先将 0，4，8，12，。。。位置进行插入排序
  - 再将 0，2，4，6，8，。。。位置进行插入排序
  - 最后将 0，1，2，3，4，。。。位置进行插入排序

# 归并排序: O(N*logN)

两个子数组（对半劈）排好顺序，然后合并到新数组，递归子数组

过程：3个指针 两个子数组指针 一个新数组指针，2个子数组指针后移比较 放到新数组 新数组指针后移

master = 2 * T(N/2) + O(N);  两半为 T(N/2), O(N) 为merge

## 递归版



## 迭代版

- 定义步长=1 遇到步长为左组 再遇到步长为右组 进行merge
- 步长 *= 2 再merge
- 步长 *= 2 再merge
- ...

- 例如9个数 {3,2,4,6,7,1,9,5,8}
- 步长=1: 3-2 4-6 7-1 9-5 8 -> 23 46 17 59 8
- 步长=2: 23-46   17-59   8 -> 2346  1579  8
- 步长=4: 2346-1579       8 -> 12345679    8
- 步长=8: 12345679-8        -> 123456789

注意 int 有越界问题 步长<Integer.MAX 步长*2>Integer.MAX

## 题

```

面试题
1 小核 每个位置的数左侧比他小的数累加 再计算累加的累加
2 逆序对
3 >=
```



# TIM SORT

java内部 对象排序（要求稳定）使用的是改进的归并排序 叫TIM SORT

过程：多路归并 先分多块 然后两两归并 再两两归并 。。。

# 快速排序：单轴快排

过程：找到一个轴，小于轴的放到左边大于轴的放到右边

# 双轴快排：

Arrays.sort(基础数据类型)
